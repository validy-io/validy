package io.validy.core;

import io.validy.core.result.ValidationError;
import io.validy.core.result.ValidationResult;

/**
 * A single validation rule for type {@code T}.
 *
 * <p>Rules are composable via {@code and}, {@code or}, and {@code negate}.
 * They are plain functional interfaces — lambdas, method refs, or classes all work.
 *
 * @param <T> the type being validated
 */
@FunctionalInterface
public interface Rule<T> {

    ValidationResult validate(T value);

    // ── Combinators ───────────────────────────────────────────────────────────

    /** Both this AND the other rule must pass (all errors collected). */
    default Rule<T> and(Rule<T> other) {
        return value -> this.validate(value).and(other.validate(value));
    }

    /** This OR the other rule must pass (short-circuits on first success). */
    default Rule<T> or(Rule<T> other) {
        return value -> {
            var result = this.validate(value);
            return result.isValid() ? result : other.validate(value);
        };
    }

    /** Inverts this rule — pass becomes fail and vice versa. */
    default Rule<T> negate(String failMessage) {
        return value -> this.validate(value).isValid()
                ? ValidationResult.invalid("$", failMessage)
                : ValidationResult.valid();
    }

    /** Attaches a custom error message, replacing any generated by this rule. */
    default Rule<T> withMessage(String field, String message) {
        return value -> this.validate(value).isValid()
                ? ValidationResult.valid()
                : ValidationResult.invalid(field, message);
    }

    /** Named alias — improves DSL readability. */
    default Rule<T> as(String name) {
        return value -> switch (this.validate(value)) {
            case ValidationResult.Valid v -> v;
            case ValidationResult.Invalid(var errors) ->
                    ValidationResult.invalid(
                            errors.stream()
                                    .map(e -> new ValidationError(name, e.message()))
                                    .toList()
                    );
        };
    }
}